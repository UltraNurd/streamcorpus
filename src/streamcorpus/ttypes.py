#
# Autogenerated by Thrift Compiler (0.8.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style,slots
#

from thrift.Thrift import TType, TMessageType, TException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class OffsetType(object):
  """
  Offset and OffsetType are used by Annotation to identify the
  portion of a ContentItem that a human labeled with a tag.
  """
  LINES = 0
  BYTES = 1
  CHARS = 2

  _VALUES_TO_NAMES = {
    0: "LINES",
    1: "BYTES",
    2: "CHARS",
  }

  _NAMES_TO_VALUES = {
    "LINES": 0,
    "BYTES": 1,
    "CHARS": 2,
  }

class EntityType(object):
  """
  Different tagging tools have different strings for labeling the
  various common entity types.  To avoid ambiguity, we define a
  canonical list here, which we will surely have to expand over time
  as new taggers recognize new types of entities.
  """
  PER = 0
  ORG = 1
  LOC = 2
  MALE_PRONOUN = 3
  FEMALE_PRONOUN = 4
  TIME = 5
  DATE = 6
  MONEY = 7
  PERCENT = 8
  MISC = 9

  _VALUES_TO_NAMES = {
    0: "PER",
    1: "ORG",
    2: "LOC",
    3: "MALE_PRONOUN",
    4: "FEMALE_PRONOUN",
    5: "TIME",
    6: "DATE",
    7: "MONEY",
    8: "PERCENT",
    9: "MISC",
  }

  _NAMES_TO_VALUES = {
    "PER": 0,
    "ORG": 1,
    "LOC": 2,
    "MALE_PRONOUN": 3,
    "FEMALE_PRONOUN": 4,
    "TIME": 5,
    "DATE": 6,
    "MONEY": 7,
    "PERCENT": 8,
    "MISC": 9,
  }

class Versions(object):
  """
  Versions of this protocol are enumerated so that when we expand,
  everybody can see which version a particular data file used.
  """
  v0_2_0 = 0

  _VALUES_TO_NAMES = {
    0: "v0_2_0",
  }

  _NAMES_TO_VALUES = {
    "v0_2_0": 0,
  }


class StreamTime(object):
  """
  StreamTime is a timestamp measured in seconds since the 1970 epoch.
  epoch_ticks is always in the UTC timezone.  This is used in several
  structs below to record various moments in history.

  Attributes:
   - epoch_ticks
   - zulu_timestamp
  """

  __slots__ = [ 
    'epoch_ticks',
    'zulu_timestamp',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'epoch_ticks', None, None, ), # 1
    (2, TType.STRING, 'zulu_timestamp', None, None, ), # 2
  )

  def __init__(self, epoch_ticks=None, zulu_timestamp=None,):
    self.epoch_ticks = epoch_ticks
    self.zulu_timestamp = zulu_timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.epoch_ticks = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.zulu_timestamp = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamTime')
    if self.epoch_ticks is not None:
      oprot.writeFieldBegin('epoch_ticks', TType.DOUBLE, 1)
      oprot.writeDouble(self.epoch_ticks)
      oprot.writeFieldEnd()
    if self.zulu_timestamp is not None:
      oprot.writeFieldBegin('zulu_timestamp', TType.STRING, 2)
      oprot.writeString(self.zulu_timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Annotator(object):
  """
  An Annotator object describes a human (or possibly a set of humans)
  who generated the data stored in a Label or Rating object.

  Attributes:
   - annotator_id
   - annotation_time
   - reference_kb
   - kb_snapshot_time
  """

  __slots__ = [ 
    'annotator_id',
    'annotation_time',
    'reference_kb',
    'kb_snapshot_time',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'annotator_id', None, None, ), # 1
    (2, TType.STRUCT, 'annotation_time', (StreamTime, StreamTime.thrift_spec), None, ), # 2
    (3, TType.STRING, 'reference_kb', None, None, ), # 3
    (4, TType.STRUCT, 'kb_snapshot_time', (StreamTime, StreamTime.thrift_spec), None, ), # 4
  )

  def __init__(self, annotator_id=None, annotation_time=None, reference_kb=None, kb_snapshot_time=None,):
    self.annotator_id = annotator_id
    self.annotation_time = annotation_time
    self.reference_kb = reference_kb
    self.kb_snapshot_time = kb_snapshot_time

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.annotator_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.annotation_time = StreamTime()
          self.annotation_time.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.reference_kb = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.kb_snapshot_time = StreamTime()
          self.kb_snapshot_time.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Annotator')
    if self.annotator_id is not None:
      oprot.writeFieldBegin('annotator_id', TType.STRING, 1)
      oprot.writeString(self.annotator_id)
      oprot.writeFieldEnd()
    if self.annotation_time is not None:
      oprot.writeFieldBegin('annotation_time', TType.STRUCT, 2)
      self.annotation_time.write(oprot)
      oprot.writeFieldEnd()
    if self.reference_kb is not None:
      oprot.writeFieldBegin('reference_kb', TType.STRING, 3)
      oprot.writeString(self.reference_kb)
      oprot.writeFieldEnd()
    if self.kb_snapshot_time is not None:
      oprot.writeFieldBegin('kb_snapshot_time', TType.STRUCT, 4)
      self.kb_snapshot_time.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Offset(object):
  """
  Attributes:
   - type
   - first
   - length
   - xpath
   - content_form
   - value
  """

  __slots__ = [ 
    'type',
    'first',
    'length',
    'xpath',
    'content_form',
    'value',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.I64, 'first', None, None, ), # 2
    (3, TType.I32, 'length', None, None, ), # 3
    (4, TType.STRING, 'xpath', None, None, ), # 4
    (5, TType.STRING, 'content_form', None, None, ), # 5
    (6, TType.STRING, 'value', None, None, ), # 6
  )

  def __init__(self, type=None, first=None, length=None, xpath=None, content_form=None, value=None,):
    self.type = type
    self.first = first
    self.length = length
    self.xpath = xpath
    self.content_form = content_form
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.first = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.length = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.xpath = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.content_form = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.value = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Offset')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.first is not None:
      oprot.writeFieldBegin('first', TType.I64, 2)
      oprot.writeI64(self.first)
      oprot.writeFieldEnd()
    if self.length is not None:
      oprot.writeFieldBegin('length', TType.I32, 3)
      oprot.writeI32(self.length)
      oprot.writeFieldEnd()
    if self.xpath is not None:
      oprot.writeFieldBegin('xpath', TType.STRING, 4)
      oprot.writeString(self.xpath)
      oprot.writeFieldEnd()
    if self.content_form is not None:
      oprot.writeFieldBegin('content_form', TType.STRING, 5)
      oprot.writeString(self.content_form)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 6)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Label(object):
  """
  Labels are human generated assertions about a portion of a document
  For example, a human author might label their own text by inserting
  hyperlinks to Wikipedia, or a NIST assessor might record which
  tokens in a text mention a target entity.

  Label instances can be attached to an individual Token and
  Sentence, or in a LabelSet.labels describing multiple parts of a
  piece of data in a ContentItem.

  Attributes:
   - target_id
   - offsets
   - annotator
  """

  __slots__ = [ 
    'target_id',
    'offsets',
    'annotator',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'target_id', None, None, ), # 1
    (2, TType.MAP, 'offsets', (TType.I32,None,TType.STRUCT,(Offset, Offset.thrift_spec)), {
    }, ), # 2
    (3, TType.STRUCT, 'annotator', (Annotator, Annotator.thrift_spec), None, ), # 3
  )

  def __init__(self, target_id=None, offsets=thrift_spec[2][4], annotator=None,):
    self.target_id = target_id
    if offsets is self.thrift_spec[2][4]:
      offsets = {
    }
    self.offsets = offsets
    self.annotator = annotator

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.target_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.offsets = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          for _i4 in xrange(_size0):
            _key5 = iprot.readI32();
            _val6 = Offset()
            _val6.read(iprot)
            self.offsets[_key5] = _val6
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.annotator = Annotator()
          self.annotator.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Label')
    if self.target_id is not None:
      oprot.writeFieldBegin('target_id', TType.STRING, 1)
      oprot.writeString(self.target_id)
      oprot.writeFieldEnd()
    if self.offsets is not None:
      oprot.writeFieldBegin('offsets', TType.MAP, 2)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.offsets))
      for kiter7,viter8 in self.offsets.items():
        oprot.writeI32(kiter7)
        viter8.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.annotator is not None:
      oprot.writeFieldBegin('annotator', TType.STRUCT, 3)
      self.annotator.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class LabelSet(object):
  """
  Attributes:
   - annotator
   - labels
  """

  __slots__ = [ 
    'annotator',
    'labels',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'annotator', (Annotator, Annotator.thrift_spec), None, ), # 1
    (2, TType.LIST, 'labels', (TType.STRUCT,(Label, Label.thrift_spec)), [
    ], ), # 2
  )

  def __init__(self, annotator=None, labels=thrift_spec[2][4],):
    self.annotator = annotator
    if labels is self.thrift_spec[2][4]:
      labels = [
    ]
    self.labels = labels

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.annotator = Annotator()
          self.annotator.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.labels = []
          (_etype12, _size9) = iprot.readListBegin()
          for _i13 in xrange(_size9):
            _elem14 = Label()
            _elem14.read(iprot)
            self.labels.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LabelSet')
    if self.annotator is not None:
      oprot.writeFieldBegin('annotator', TType.STRUCT, 1)
      self.annotator.write(oprot)
      oprot.writeFieldEnd()
    if self.labels is not None:
      oprot.writeFieldBegin('labels', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.labels))
      for iter15 in self.labels:
        iter15.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Token(object):
  """
  Textual tokens identified by an NLP pipeline and marked up with
  metadata from automatic taggers and possibly also Labels from
  humans.

  Attributes:
   - token_num
   - token
   - offsets
   - sentence_pos
   - lemma
   - pos
   - entity_type
   - mention_id
   - equiv_id
   - parent_id
   - dependency_path
   - labels
  """

  __slots__ = [ 
    'token_num',
    'token',
    'offsets',
    'sentence_pos',
    'lemma',
    'pos',
    'entity_type',
    'mention_id',
    'equiv_id',
    'parent_id',
    'dependency_path',
    'labels',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'token_num', None, None, ), # 1
    (2, TType.STRING, 'token', None, None, ), # 2
    (3, TType.MAP, 'offsets', (TType.I32,None,TType.STRUCT,(Offset, Offset.thrift_spec)), {
    }, ), # 3
    (4, TType.I32, 'sentence_pos', None, -1, ), # 4
    (5, TType.STRING, 'lemma', None, None, ), # 5
    (6, TType.STRING, 'pos', None, None, ), # 6
    (7, TType.I32, 'entity_type', None, None, ), # 7
    (8, TType.I16, 'mention_id', None, -1, ), # 8
    (9, TType.I32, 'equiv_id', None, -1, ), # 9
    (10, TType.I32, 'parent_id', None, -1, ), # 10
    (11, TType.STRING, 'dependency_path', None, None, ), # 11
    (12, TType.LIST, 'labels', (TType.STRUCT,(Label, Label.thrift_spec)), [
    ], ), # 12
  )

  def __init__(self, token_num=None, token=None, offsets=thrift_spec[3][4], sentence_pos=thrift_spec[4][4], lemma=None, pos=None, entity_type=None, mention_id=thrift_spec[8][4], equiv_id=thrift_spec[9][4], parent_id=thrift_spec[10][4], dependency_path=None, labels=thrift_spec[12][4],):
    self.token_num = token_num
    self.token = token
    if offsets is self.thrift_spec[3][4]:
      offsets = {
    }
    self.offsets = offsets
    self.sentence_pos = sentence_pos
    self.lemma = lemma
    self.pos = pos
    self.entity_type = entity_type
    self.mention_id = mention_id
    self.equiv_id = equiv_id
    self.parent_id = parent_id
    self.dependency_path = dependency_path
    if labels is self.thrift_spec[12][4]:
      labels = [
    ]
    self.labels = labels

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.token_num = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.token = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.offsets = {}
          (_ktype17, _vtype18, _size16 ) = iprot.readMapBegin() 
          for _i20 in xrange(_size16):
            _key21 = iprot.readI32();
            _val22 = Offset()
            _val22.read(iprot)
            self.offsets[_key21] = _val22
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.sentence_pos = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.lemma = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.pos = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.entity_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I16:
          self.mention_id = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I32:
          self.equiv_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I32:
          self.parent_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.dependency_path = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.labels = []
          (_etype26, _size23) = iprot.readListBegin()
          for _i27 in xrange(_size23):
            _elem28 = Label()
            _elem28.read(iprot)
            self.labels.append(_elem28)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Token')
    if self.token_num is not None:
      oprot.writeFieldBegin('token_num', TType.I32, 1)
      oprot.writeI32(self.token_num)
      oprot.writeFieldEnd()
    if self.token is not None:
      oprot.writeFieldBegin('token', TType.STRING, 2)
      oprot.writeString(self.token)
      oprot.writeFieldEnd()
    if self.offsets is not None:
      oprot.writeFieldBegin('offsets', TType.MAP, 3)
      oprot.writeMapBegin(TType.I32, TType.STRUCT, len(self.offsets))
      for kiter29,viter30 in self.offsets.items():
        oprot.writeI32(kiter29)
        viter30.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.sentence_pos is not None:
      oprot.writeFieldBegin('sentence_pos', TType.I32, 4)
      oprot.writeI32(self.sentence_pos)
      oprot.writeFieldEnd()
    if self.lemma is not None:
      oprot.writeFieldBegin('lemma', TType.STRING, 5)
      oprot.writeString(self.lemma)
      oprot.writeFieldEnd()
    if self.pos is not None:
      oprot.writeFieldBegin('pos', TType.STRING, 6)
      oprot.writeString(self.pos)
      oprot.writeFieldEnd()
    if self.entity_type is not None:
      oprot.writeFieldBegin('entity_type', TType.I32, 7)
      oprot.writeI32(self.entity_type)
      oprot.writeFieldEnd()
    if self.mention_id is not None:
      oprot.writeFieldBegin('mention_id', TType.I16, 8)
      oprot.writeI16(self.mention_id)
      oprot.writeFieldEnd()
    if self.equiv_id is not None:
      oprot.writeFieldBegin('equiv_id', TType.I32, 9)
      oprot.writeI32(self.equiv_id)
      oprot.writeFieldEnd()
    if self.parent_id is not None:
      oprot.writeFieldBegin('parent_id', TType.I32, 10)
      oprot.writeI32(self.parent_id)
      oprot.writeFieldEnd()
    if self.dependency_path is not None:
      oprot.writeFieldBegin('dependency_path', TType.STRING, 11)
      oprot.writeString(self.dependency_path)
      oprot.writeFieldEnd()
    if self.labels is not None:
      oprot.writeFieldBegin('labels', TType.LIST, 12)
      oprot.writeListBegin(TType.STRUCT, len(self.labels))
      for iter31 in self.labels:
        iter31.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Sentence(object):
  """
  Attributes:
   - tokens
   - labels
  """

  __slots__ = [ 
    'tokens',
    'labels',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'tokens', (TType.STRUCT,(Token, Token.thrift_spec)), [
    ], ), # 1
    (2, TType.LIST, 'labels', (TType.STRUCT,(Label, Label.thrift_spec)), [
    ], ), # 2
  )

  def __init__(self, tokens=thrift_spec[1][4], labels=thrift_spec[2][4],):
    if tokens is self.thrift_spec[1][4]:
      tokens = [
    ]
    self.tokens = tokens
    if labels is self.thrift_spec[2][4]:
      labels = [
    ]
    self.labels = labels

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.tokens = []
          (_etype35, _size32) = iprot.readListBegin()
          for _i36 in xrange(_size32):
            _elem37 = Token()
            _elem37.read(iprot)
            self.tokens.append(_elem37)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.labels = []
          (_etype41, _size38) = iprot.readListBegin()
          for _i42 in xrange(_size38):
            _elem43 = Label()
            _elem43.read(iprot)
            self.labels.append(_elem43)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Sentence')
    if self.tokens is not None:
      oprot.writeFieldBegin('tokens', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.tokens))
      for iter44 in self.tokens:
        iter44.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.labels is not None:
      oprot.writeFieldBegin('labels', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.labels))
      for iter45 in self.labels:
        iter45.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Tagging(object):
  """
  Attributes:
   - tagger_id
   - raw_tagging
   - tagger_config
   - tagger_version
   - generation_time
  """

  __slots__ = [ 
    'tagger_id',
    'raw_tagging',
    'tagger_config',
    'tagger_version',
    'generation_time',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'tagger_id', None, None, ), # 1
    (2, TType.STRING, 'raw_tagging', None, None, ), # 2
    (3, TType.STRING, 'tagger_config', None, None, ), # 3
    (4, TType.STRING, 'tagger_version', None, None, ), # 4
    (5, TType.STRUCT, 'generation_time', (StreamTime, StreamTime.thrift_spec), None, ), # 5
  )

  def __init__(self, tagger_id=None, raw_tagging=None, tagger_config=None, tagger_version=None, generation_time=None,):
    self.tagger_id = tagger_id
    self.raw_tagging = raw_tagging
    self.tagger_config = tagger_config
    self.tagger_version = tagger_version
    self.generation_time = generation_time

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.tagger_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.raw_tagging = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.tagger_config = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.tagger_version = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.generation_time = StreamTime()
          self.generation_time.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Tagging')
    if self.tagger_id is not None:
      oprot.writeFieldBegin('tagger_id', TType.STRING, 1)
      oprot.writeString(self.tagger_id)
      oprot.writeFieldEnd()
    if self.raw_tagging is not None:
      oprot.writeFieldBegin('raw_tagging', TType.STRING, 2)
      oprot.writeString(self.raw_tagging)
      oprot.writeFieldEnd()
    if self.tagger_config is not None:
      oprot.writeFieldBegin('tagger_config', TType.STRING, 3)
      oprot.writeString(self.tagger_config)
      oprot.writeFieldEnd()
    if self.tagger_version is not None:
      oprot.writeFieldBegin('tagger_version', TType.STRING, 4)
      oprot.writeString(self.tagger_version)
      oprot.writeFieldEnd()
    if self.generation_time is not None:
      oprot.writeFieldBegin('generation_time', TType.STRUCT, 5)
      self.generation_time.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class ContentItem(object):
  """
  ContentItem contains raw data, an indication of its character
  encoding, and various transformed versions of the raw data.

  Attributes:
   - raw
   - encoding
   - media_type
   - clean_html
   - clean_visible
   - logs
   - taggings
   - labelsets
   - sentences
   - sentence_blobs
  """

  __slots__ = [ 
    'raw',
    'encoding',
    'media_type',
    'clean_html',
    'clean_visible',
    'logs',
    'taggings',
    'labelsets',
    'sentences',
    'sentence_blobs',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'raw', None, None, ), # 1
    (2, TType.STRING, 'encoding', None, None, ), # 2
    (3, TType.STRING, 'media_type', None, None, ), # 3
    (4, TType.STRING, 'clean_html', None, None, ), # 4
    (5, TType.STRING, 'clean_visible', None, None, ), # 5
    (6, TType.LIST, 'logs', (TType.STRING,None), [
    ], ), # 6
    (7, TType.MAP, 'taggings', (TType.STRING,None,TType.STRUCT,(Tagging, Tagging.thrift_spec)), {
    }, ), # 7
    (8, TType.LIST, 'labelsets', (TType.STRUCT,(LabelSet, LabelSet.thrift_spec)), [
    ], ), # 8
    (9, TType.MAP, 'sentences', (TType.STRING,None,TType.LIST,(TType.STRUCT,(Sentence, Sentence.thrift_spec))), {
    }, ), # 9
    (10, TType.MAP, 'sentence_blobs', (TType.STRING,None,TType.STRING,None), {
    }, ), # 10
  )

  def __init__(self, raw=None, encoding=None, media_type=None, clean_html=None, clean_visible=None, logs=thrift_spec[6][4], taggings=thrift_spec[7][4], labelsets=thrift_spec[8][4], sentences=thrift_spec[9][4], sentence_blobs=thrift_spec[10][4],):
    self.raw = raw
    self.encoding = encoding
    self.media_type = media_type
    self.clean_html = clean_html
    self.clean_visible = clean_visible
    if logs is self.thrift_spec[6][4]:
      logs = [
    ]
    self.logs = logs
    if taggings is self.thrift_spec[7][4]:
      taggings = {
    }
    self.taggings = taggings
    if labelsets is self.thrift_spec[8][4]:
      labelsets = [
    ]
    self.labelsets = labelsets
    if sentences is self.thrift_spec[9][4]:
      sentences = {
    }
    self.sentences = sentences
    if sentence_blobs is self.thrift_spec[10][4]:
      sentence_blobs = {
    }
    self.sentence_blobs = sentence_blobs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.raw = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.encoding = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.media_type = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.clean_html = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.clean_visible = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.logs = []
          (_etype49, _size46) = iprot.readListBegin()
          for _i50 in xrange(_size46):
            _elem51 = iprot.readString();
            self.logs.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.taggings = {}
          (_ktype53, _vtype54, _size52 ) = iprot.readMapBegin() 
          for _i56 in xrange(_size52):
            _key57 = iprot.readString();
            _val58 = Tagging()
            _val58.read(iprot)
            self.taggings[_key57] = _val58
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.LIST:
          self.labelsets = []
          (_etype62, _size59) = iprot.readListBegin()
          for _i63 in xrange(_size59):
            _elem64 = LabelSet()
            _elem64.read(iprot)
            self.labelsets.append(_elem64)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.sentences = {}
          (_ktype66, _vtype67, _size65 ) = iprot.readMapBegin() 
          for _i69 in xrange(_size65):
            _key70 = iprot.readString();
            _val71 = []
            (_etype75, _size72) = iprot.readListBegin()
            for _i76 in xrange(_size72):
              _elem77 = Sentence()
              _elem77.read(iprot)
              _val71.append(_elem77)
            iprot.readListEnd()
            self.sentences[_key70] = _val71
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.MAP:
          self.sentence_blobs = {}
          (_ktype79, _vtype80, _size78 ) = iprot.readMapBegin() 
          for _i82 in xrange(_size78):
            _key83 = iprot.readString();
            _val84 = iprot.readString();
            self.sentence_blobs[_key83] = _val84
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ContentItem')
    if self.raw is not None:
      oprot.writeFieldBegin('raw', TType.STRING, 1)
      oprot.writeString(self.raw)
      oprot.writeFieldEnd()
    if self.encoding is not None:
      oprot.writeFieldBegin('encoding', TType.STRING, 2)
      oprot.writeString(self.encoding)
      oprot.writeFieldEnd()
    if self.media_type is not None:
      oprot.writeFieldBegin('media_type', TType.STRING, 3)
      oprot.writeString(self.media_type)
      oprot.writeFieldEnd()
    if self.clean_html is not None:
      oprot.writeFieldBegin('clean_html', TType.STRING, 4)
      oprot.writeString(self.clean_html)
      oprot.writeFieldEnd()
    if self.clean_visible is not None:
      oprot.writeFieldBegin('clean_visible', TType.STRING, 5)
      oprot.writeString(self.clean_visible)
      oprot.writeFieldEnd()
    if self.logs is not None:
      oprot.writeFieldBegin('logs', TType.LIST, 6)
      oprot.writeListBegin(TType.STRING, len(self.logs))
      for iter85 in self.logs:
        oprot.writeString(iter85)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.taggings is not None:
      oprot.writeFieldBegin('taggings', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.taggings))
      for kiter86,viter87 in self.taggings.items():
        oprot.writeString(kiter86)
        viter87.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.labelsets is not None:
      oprot.writeFieldBegin('labelsets', TType.LIST, 8)
      oprot.writeListBegin(TType.STRUCT, len(self.labelsets))
      for iter88 in self.labelsets:
        iter88.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.sentences is not None:
      oprot.writeFieldBegin('sentences', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.sentences))
      for kiter89,viter90 in self.sentences.items():
        oprot.writeString(kiter89)
        oprot.writeListBegin(TType.STRUCT, len(viter90))
        for iter91 in viter90:
          iter91.write(oprot)
        oprot.writeListEnd()
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.sentence_blobs is not None:
      oprot.writeFieldBegin('sentence_blobs', TType.MAP, 10)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.sentence_blobs))
      for kiter92,viter93 in self.sentence_blobs.items():
        oprot.writeString(kiter92)
        oprot.writeString(viter93)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class Rating(object):
  """
  Ratings are buman generated assertions about a entire document's
  utility for a particular topic or entity in a reference KB.

  Attributes:
   - annotator
   - target_id
   - relevance
   - mentions
  """

  __slots__ = [ 
    'annotator',
    'target_id',
    'relevance',
    'mentions',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'annotator', (Annotator, Annotator.thrift_spec), None, ), # 1
    (2, TType.STRING, 'target_id', None, None, ), # 2
    (3, TType.I16, 'relevance', None, None, ), # 3
    (4, TType.BOOL, 'mentions', None, None, ), # 4
  )

  def __init__(self, annotator=None, target_id=None, relevance=None, mentions=None,):
    self.annotator = annotator
    self.target_id = target_id
    self.relevance = relevance
    self.mentions = mentions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.annotator = Annotator()
          self.annotator.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.target_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.relevance = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.mentions = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('Rating')
    if self.annotator is not None:
      oprot.writeFieldBegin('annotator', TType.STRUCT, 1)
      self.annotator.write(oprot)
      oprot.writeFieldEnd()
    if self.target_id is not None:
      oprot.writeFieldBegin('target_id', TType.STRING, 2)
      oprot.writeString(self.target_id)
      oprot.writeFieldEnd()
    if self.relevance is not None:
      oprot.writeFieldBegin('relevance', TType.I16, 3)
      oprot.writeI16(self.relevance)
      oprot.writeFieldEnd()
    if self.mentions is not None:
      oprot.writeFieldBegin('mentions', TType.BOOL, 4)
      oprot.writeBool(self.mentions)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)


class StreamItem(object):
  """
  This is the primary interface to the corpus data.  It is called
  StreamItem rather than CorpusItem and has a required StreamTime
  attribute, because even for a static corpus, each document was
  captured at a particular time in Earth history and might have been
  different if captured earlier or later.  All corpora are stream
  corpora, even if they were not explicitly created as such.

  stream_id is the unique identifier for documents in the corpus.

  This is mostly the same as the StreamItem defined in kba.thrift for
  TREC KBA 2012, however it removes the 'title' and 'anchor' fields,
  which can now be represented in other_content.  This means that
  code that was written to read messages from kba.thrift must be
  updated.

  Attributes:
   - version
   - doc_id
   - abs_url
   - schost
   - original_url
   - source
   - body
   - source_metadata
   - stream_id
   - stream_time
   - other_content
   - ratings
  """

  __slots__ = [ 
    'version',
    'doc_id',
    'abs_url',
    'schost',
    'original_url',
    'source',
    'body',
    'source_metadata',
    'stream_id',
    'stream_time',
    'other_content',
    'ratings',
   ]

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'version', None, None, ), # 1
    (2, TType.STRING, 'doc_id', None, None, ), # 2
    (3, TType.STRING, 'abs_url', None, None, ), # 3
    (4, TType.STRING, 'schost', None, None, ), # 4
    (5, TType.STRING, 'original_url', None, None, ), # 5
    (6, TType.STRING, 'source', None, None, ), # 6
    (7, TType.STRUCT, 'body', (ContentItem, ContentItem.thrift_spec), None, ), # 7
    (8, TType.MAP, 'source_metadata', (TType.STRING,None,TType.STRING,None), {
    }, ), # 8
    (9, TType.STRING, 'stream_id', None, None, ), # 9
    (10, TType.STRUCT, 'stream_time', (StreamTime, StreamTime.thrift_spec), None, ), # 10
    (11, TType.MAP, 'other_content', (TType.STRING,None,TType.STRUCT,(ContentItem, ContentItem.thrift_spec)), {
    }, ), # 11
    (12, TType.LIST, 'ratings', (TType.STRUCT,(Rating, Rating.thrift_spec)), [
    ], ), # 12
  )

  def __init__(self, version=None, doc_id=None, abs_url=None, schost=None, original_url=None, source=None, body=None, source_metadata=thrift_spec[8][4], stream_id=None, stream_time=None, other_content=thrift_spec[11][4], ratings=thrift_spec[12][4],):
    self.version = version
    self.doc_id = doc_id
    self.abs_url = abs_url
    self.schost = schost
    self.original_url = original_url
    self.source = source
    self.body = body
    if source_metadata is self.thrift_spec[8][4]:
      source_metadata = {
    }
    self.source_metadata = source_metadata
    self.stream_id = stream_id
    self.stream_time = stream_time
    if other_content is self.thrift_spec[11][4]:
      other_content = {
    }
    self.other_content = other_content
    if ratings is self.thrift_spec[12][4]:
      ratings = [
    ]
    self.ratings = ratings

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.version = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.doc_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.abs_url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.schost = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.original_url = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.source = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.body = ContentItem()
          self.body.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.MAP:
          self.source_metadata = {}
          (_ktype95, _vtype96, _size94 ) = iprot.readMapBegin() 
          for _i98 in xrange(_size94):
            _key99 = iprot.readString();
            _val100 = iprot.readString();
            self.source_metadata[_key99] = _val100
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.stream_id = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.stream_time = StreamTime()
          self.stream_time.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.MAP:
          self.other_content = {}
          (_ktype102, _vtype103, _size101 ) = iprot.readMapBegin() 
          for _i105 in xrange(_size101):
            _key106 = iprot.readString();
            _val107 = ContentItem()
            _val107.read(iprot)
            self.other_content[_key106] = _val107
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.LIST:
          self.ratings = []
          (_etype111, _size108) = iprot.readListBegin()
          for _i112 in xrange(_size108):
            _elem113 = Rating()
            _elem113.read(iprot)
            self.ratings.append(_elem113)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('StreamItem')
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I32, 1)
      oprot.writeI32(self.version)
      oprot.writeFieldEnd()
    if self.doc_id is not None:
      oprot.writeFieldBegin('doc_id', TType.STRING, 2)
      oprot.writeString(self.doc_id)
      oprot.writeFieldEnd()
    if self.abs_url is not None:
      oprot.writeFieldBegin('abs_url', TType.STRING, 3)
      oprot.writeString(self.abs_url)
      oprot.writeFieldEnd()
    if self.schost is not None:
      oprot.writeFieldBegin('schost', TType.STRING, 4)
      oprot.writeString(self.schost)
      oprot.writeFieldEnd()
    if self.original_url is not None:
      oprot.writeFieldBegin('original_url', TType.STRING, 5)
      oprot.writeString(self.original_url)
      oprot.writeFieldEnd()
    if self.source is not None:
      oprot.writeFieldBegin('source', TType.STRING, 6)
      oprot.writeString(self.source)
      oprot.writeFieldEnd()
    if self.body is not None:
      oprot.writeFieldBegin('body', TType.STRUCT, 7)
      self.body.write(oprot)
      oprot.writeFieldEnd()
    if self.source_metadata is not None:
      oprot.writeFieldBegin('source_metadata', TType.MAP, 8)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.source_metadata))
      for kiter114,viter115 in self.source_metadata.items():
        oprot.writeString(kiter114)
        oprot.writeString(viter115)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.stream_id is not None:
      oprot.writeFieldBegin('stream_id', TType.STRING, 9)
      oprot.writeString(self.stream_id)
      oprot.writeFieldEnd()
    if self.stream_time is not None:
      oprot.writeFieldBegin('stream_time', TType.STRUCT, 10)
      self.stream_time.write(oprot)
      oprot.writeFieldEnd()
    if self.other_content is not None:
      oprot.writeFieldBegin('other_content', TType.MAP, 11)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.other_content))
      for kiter116,viter117 in self.other_content.items():
        oprot.writeString(kiter116)
        viter117.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.ratings is not None:
      oprot.writeFieldBegin('ratings', TType.LIST, 12)
      oprot.writeListBegin(TType.STRUCT, len(self.ratings))
      for iter118 in self.ratings:
        iter118.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __repr__(self):
    L = ['%s=%r' % (key, getattr(self, key))
      for key in self.__slots__]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False
    for attr in self.__slots__:
      my_val = getattr(self, attr)
      other_val = getattr(other, attr)
      if my_val != other_val:
        return False
    return True

  def __ne__(self, other):
    return not (self == other)

