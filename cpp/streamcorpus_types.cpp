/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "streamcorpus_types.h"

#include <algorithm>



int _kOffsetTypeValues[] = {
  OffsetType::LINES,
  OffsetType::BYTES,
  OffsetType::CHARS
};
const char* _kOffsetTypeNames[] = {
  "LINES",
  "BYTES",
  "CHARS"
};
const std::map<int, const char*> _OffsetType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kOffsetTypeValues, _kOffsetTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kEntityTypeValues[] = {
  EntityType::PER,
  EntityType::ORG,
  EntityType::LOC,
  EntityType::MALE_PRONOUN,
  EntityType::FEMALE_PRONOUN,
  EntityType::TIME,
  EntityType::DATE,
  EntityType::MONEY,
  EntityType::PERCENT,
  EntityType::MISC
};
const char* _kEntityTypeNames[] = {
  "PER",
  "ORG",
  "LOC",
  "MALE_PRONOUN",
  "FEMALE_PRONOUN",
  "TIME",
  "DATE",
  "MONEY",
  "PERCENT",
  "MISC"
};
const std::map<int, const char*> _EntityType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kEntityTypeValues, _kEntityTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kVersionsValues[] = {
  Versions::v0_2_0
};
const char* _kVersionsNames[] = {
  "v0_2_0"
};
const std::map<int, const char*> _Versions_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kVersionsValues, _kVersionsNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* StreamTime::ascii_fingerprint = "DD2684E5F49042C4C07B5348ECFFFD06";
const uint8_t StreamTime::binary_fingerprint[16] = {0xDD,0x26,0x84,0xE5,0xF4,0x90,0x42,0xC4,0xC0,0x7B,0x53,0x48,0xEC,0xFF,0xFD,0x06};

uint32_t StreamTime::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->epoch_ticks);
          this->__isset.epoch_ticks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zulu_timestamp);
          this->__isset.zulu_timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StreamTime::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StreamTime");

  xfer += oprot->writeFieldBegin("epoch_ticks", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->epoch_ticks);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zulu_timestamp", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->zulu_timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StreamTime &a, StreamTime &b) {
  using ::std::swap;
  swap(a.epoch_ticks, b.epoch_ticks);
  swap(a.zulu_timestamp, b.zulu_timestamp);
  swap(a.__isset, b.__isset);
}

const char* Annotator::ascii_fingerprint = "CE8AC238634F80029949962E65E1F48C";
const uint8_t Annotator::binary_fingerprint[16] = {0xCE,0x8A,0xC2,0x38,0x63,0x4F,0x80,0x02,0x99,0x49,0x96,0x2E,0x65,0xE1,0xF4,0x8C};

uint32_t Annotator::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->annotator_id);
          this->__isset.annotator_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotation_time.read(iprot);
          this->__isset.annotation_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->reference_kb);
          this->__isset.reference_kb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->kb_snapshot_time.read(iprot);
          this->__isset.kb_snapshot_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Annotator::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Annotator");

  xfer += oprot->writeFieldBegin("annotator_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->annotator_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.annotation_time) {
    xfer += oprot->writeFieldBegin("annotation_time", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->annotation_time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.reference_kb) {
    xfer += oprot->writeFieldBegin("reference_kb", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->reference_kb);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.kb_snapshot_time) {
    xfer += oprot->writeFieldBegin("kb_snapshot_time", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->kb_snapshot_time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Annotator &a, Annotator &b) {
  using ::std::swap;
  swap(a.annotator_id, b.annotator_id);
  swap(a.annotation_time, b.annotation_time);
  swap(a.reference_kb, b.reference_kb);
  swap(a.kb_snapshot_time, b.kb_snapshot_time);
  swap(a.__isset, b.__isset);
}

const char* Offset::ascii_fingerprint = "A20D4C3BA289AF4627C9FDEC29A1B027";
const uint8_t Offset::binary_fingerprint[16] = {0xA2,0x0D,0x4C,0x3B,0xA2,0x89,0xAF,0x46,0x27,0xC9,0xFD,0xEC,0x29,0xA1,0xB0,0x27};

uint32_t Offset::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = (OffsetType::type)ecast0;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->first);
          this->__isset.first = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->length);
          this->__isset.length = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->xpath);
          this->__isset.xpath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content_form);
          this->__isset.content_form = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Offset::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Offset");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("first", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->first);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("length", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->length);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.xpath) {
    xfer += oprot->writeFieldBegin("xpath", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->xpath);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.content_form) {
    xfer += oprot->writeFieldBegin("content_form", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->content_form);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.value) {
    xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeBinary(this->value);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Offset &a, Offset &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.first, b.first);
  swap(a.length, b.length);
  swap(a.xpath, b.xpath);
  swap(a.content_form, b.content_form);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

const char* Label::ascii_fingerprint = "DF310CE3B6053884BBD366864CB42756";
const uint8_t Label::binary_fingerprint[16] = {0xDF,0x31,0x0C,0xE3,0xB6,0x05,0x38,0x84,0xBB,0xD3,0x66,0x86,0x4C,0xB4,0x27,0x56};

uint32_t Label::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_id);
          this->__isset.target_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->offsets.clear();
            uint32_t _size1;
            ::apache::thrift::protocol::TType _ktype2;
            ::apache::thrift::protocol::TType _vtype3;
            xfer += iprot->readMapBegin(_ktype2, _vtype3, _size1);
            uint32_t _i5;
            for (_i5 = 0; _i5 < _size1; ++_i5)
            {
              OffsetType::type _key6;
              int32_t ecast8;
              xfer += iprot->readI32(ecast8);
              _key6 = (OffsetType::type)ecast8;
              Offset& _val7 = this->offsets[_key6];
              xfer += _val7.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.offsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotator.read(iprot);
          this->__isset.annotator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Label::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Label");

  xfer += oprot->writeFieldBegin("target_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->target_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offsets) {
    xfer += oprot->writeFieldBegin("offsets", ::apache::thrift::protocol::T_MAP, 2);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->offsets.size()));
      std::map<OffsetType::type, Offset> ::const_iterator _iter9;
      for (_iter9 = this->offsets.begin(); _iter9 != this->offsets.end(); ++_iter9)
      {
        xfer += oprot->writeI32((int32_t)_iter9->first);
        xfer += _iter9->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.annotator) {
    xfer += oprot->writeFieldBegin("annotator", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->annotator.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Label &a, Label &b) {
  using ::std::swap;
  swap(a.target_id, b.target_id);
  swap(a.offsets, b.offsets);
  swap(a.annotator, b.annotator);
  swap(a.__isset, b.__isset);
}

const char* LabelSet::ascii_fingerprint = "60E41E569004427F116F1A6D648F6599";
const uint8_t LabelSet::binary_fingerprint[16] = {0x60,0xE4,0x1E,0x56,0x90,0x04,0x42,0x7F,0x11,0x6F,0x1A,0x6D,0x64,0x8F,0x65,0x99};

uint32_t LabelSet::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotator.read(iprot);
          this->__isset.annotator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->labels.clear();
            uint32_t _size10;
            ::apache::thrift::protocol::TType _etype13;
            xfer += iprot->readListBegin(_etype13, _size10);
            this->labels.resize(_size10);
            uint32_t _i14;
            for (_i14 = 0; _i14 < _size10; ++_i14)
            {
              xfer += this->labels[_i14].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LabelSet::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LabelSet");

  xfer += oprot->writeFieldBegin("annotator", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->annotator.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->labels.size()));
    std::vector<Label> ::const_iterator _iter15;
    for (_iter15 = this->labels.begin(); _iter15 != this->labels.end(); ++_iter15)
    {
      xfer += (*_iter15).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LabelSet &a, LabelSet &b) {
  using ::std::swap;
  swap(a.annotator, b.annotator);
  swap(a.labels, b.labels);
  swap(a.__isset, b.__isset);
}

const char* Token::ascii_fingerprint = "83487AC4BBC8507EC47723871C36A102";
const uint8_t Token::binary_fingerprint[16] = {0x83,0x48,0x7A,0xC4,0xBB,0xC8,0x50,0x7E,0xC4,0x77,0x23,0x87,0x1C,0x36,0xA1,0x02};

uint32_t Token::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->token_num);
          this->__isset.token_num = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->token);
          this->__isset.token = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->offsets.clear();
            uint32_t _size16;
            ::apache::thrift::protocol::TType _ktype17;
            ::apache::thrift::protocol::TType _vtype18;
            xfer += iprot->readMapBegin(_ktype17, _vtype18, _size16);
            uint32_t _i20;
            for (_i20 = 0; _i20 < _size16; ++_i20)
            {
              OffsetType::type _key21;
              int32_t ecast23;
              xfer += iprot->readI32(ecast23);
              _key21 = (OffsetType::type)ecast23;
              Offset& _val22 = this->offsets[_key21];
              xfer += _val22.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.offsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sentence_pos);
          this->__isset.sentence_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->lemma);
          this->__isset.lemma = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast24;
          xfer += iprot->readI32(ecast24);
          this->entity_type = (EntityType::type)ecast24;
          this->__isset.entity_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mention_id);
          this->__isset.mention_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->equiv_id);
          this->__isset.equiv_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->parent_id);
          this->__isset.parent_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dependency_path);
          this->__isset.dependency_path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->labels.clear();
            uint32_t _size25;
            ::apache::thrift::protocol::TType _etype28;
            xfer += iprot->readListBegin(_etype28, _size25);
            this->labels.resize(_size25);
            uint32_t _i29;
            for (_i29 = 0; _i29 < _size25; ++_i29)
            {
              xfer += this->labels[_i29].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Token::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Token");

  xfer += oprot->writeFieldBegin("token_num", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->token_num);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("token", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->token);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offsets) {
    xfer += oprot->writeFieldBegin("offsets", ::apache::thrift::protocol::T_MAP, 3);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->offsets.size()));
      std::map<OffsetType::type, Offset> ::const_iterator _iter30;
      for (_iter30 = this->offsets.begin(); _iter30 != this->offsets.end(); ++_iter30)
      {
        xfer += oprot->writeI32((int32_t)_iter30->first);
        xfer += _iter30->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_pos) {
    xfer += oprot->writeFieldBegin("sentence_pos", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->sentence_pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.lemma) {
    xfer += oprot->writeFieldBegin("lemma", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->lemma);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.entity_type) {
    xfer += oprot->writeFieldBegin("entity_type", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32((int32_t)this->entity_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mention_id) {
    xfer += oprot->writeFieldBegin("mention_id", ::apache::thrift::protocol::T_I16, 8);
    xfer += oprot->writeI16(this->mention_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.equiv_id) {
    xfer += oprot->writeFieldBegin("equiv_id", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->equiv_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.parent_id) {
    xfer += oprot->writeFieldBegin("parent_id", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->parent_id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dependency_path) {
    xfer += oprot->writeFieldBegin("dependency_path", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->dependency_path);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_LIST, 12);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->labels.size()));
      std::vector<Label> ::const_iterator _iter31;
      for (_iter31 = this->labels.begin(); _iter31 != this->labels.end(); ++_iter31)
      {
        xfer += (*_iter31).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Token &a, Token &b) {
  using ::std::swap;
  swap(a.token_num, b.token_num);
  swap(a.token, b.token);
  swap(a.offsets, b.offsets);
  swap(a.sentence_pos, b.sentence_pos);
  swap(a.lemma, b.lemma);
  swap(a.pos, b.pos);
  swap(a.entity_type, b.entity_type);
  swap(a.mention_id, b.mention_id);
  swap(a.equiv_id, b.equiv_id);
  swap(a.parent_id, b.parent_id);
  swap(a.dependency_path, b.dependency_path);
  swap(a.labels, b.labels);
  swap(a.__isset, b.__isset);
}

const char* Sentence::ascii_fingerprint = "A3B157B62D5B3B57E03EF5FC71EC7759";
const uint8_t Sentence::binary_fingerprint[16] = {0xA3,0xB1,0x57,0xB6,0x2D,0x5B,0x3B,0x57,0xE0,0x3E,0xF5,0xFC,0x71,0xEC,0x77,0x59};

uint32_t Sentence::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tokens.clear();
            uint32_t _size32;
            ::apache::thrift::protocol::TType _etype35;
            xfer += iprot->readListBegin(_etype35, _size32);
            this->tokens.resize(_size32);
            uint32_t _i36;
            for (_i36 = 0; _i36 < _size32; ++_i36)
            {
              xfer += this->tokens[_i36].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tokens = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->labels.clear();
            uint32_t _size37;
            ::apache::thrift::protocol::TType _etype40;
            xfer += iprot->readListBegin(_etype40, _size37);
            this->labels.resize(_size37);
            uint32_t _i41;
            for (_i41 = 0; _i41 < _size37; ++_i41)
            {
              xfer += this->labels[_i41].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.labels = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Sentence::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Sentence");

  xfer += oprot->writeFieldBegin("tokens", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tokens.size()));
    std::vector<Token> ::const_iterator _iter42;
    for (_iter42 = this->tokens.begin(); _iter42 != this->tokens.end(); ++_iter42)
    {
      xfer += (*_iter42).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.labels) {
    xfer += oprot->writeFieldBegin("labels", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->labels.size()));
      std::vector<Label> ::const_iterator _iter43;
      for (_iter43 = this->labels.begin(); _iter43 != this->labels.end(); ++_iter43)
      {
        xfer += (*_iter43).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Sentence &a, Sentence &b) {
  using ::std::swap;
  swap(a.tokens, b.tokens);
  swap(a.labels, b.labels);
  swap(a.__isset, b.__isset);
}

const char* Tagging::ascii_fingerprint = "0A0DFB97882FDAD8FD6CF82C36CDF3B0";
const uint8_t Tagging::binary_fingerprint[16] = {0x0A,0x0D,0xFB,0x97,0x88,0x2F,0xDA,0xD8,0xFD,0x6C,0xF8,0x2C,0x36,0xCD,0xF3,0xB0};

uint32_t Tagging::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagger_id);
          this->__isset.tagger_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->raw_tagging);
          this->__isset.raw_tagging = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagger_config);
          this->__isset.tagger_config = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tagger_version);
          this->__isset.tagger_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->generation_time.read(iprot);
          this->__isset.generation_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Tagging::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Tagging");

  xfer += oprot->writeFieldBegin("tagger_id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tagger_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raw_tagging", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->raw_tagging);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.tagger_config) {
    xfer += oprot->writeFieldBegin("tagger_config", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->tagger_config);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.tagger_version) {
    xfer += oprot->writeFieldBegin("tagger_version", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->tagger_version);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.generation_time) {
    xfer += oprot->writeFieldBegin("generation_time", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->generation_time.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Tagging &a, Tagging &b) {
  using ::std::swap;
  swap(a.tagger_id, b.tagger_id);
  swap(a.raw_tagging, b.raw_tagging);
  swap(a.tagger_config, b.tagger_config);
  swap(a.tagger_version, b.tagger_version);
  swap(a.generation_time, b.generation_time);
  swap(a.__isset, b.__isset);
}

const char* ContentItem::ascii_fingerprint = "FE1846C5E0F6B1A7278757F54468FB36";
const uint8_t ContentItem::binary_fingerprint[16] = {0xFE,0x18,0x46,0xC5,0xE0,0xF6,0xB1,0xA7,0x27,0x87,0x57,0xF5,0x44,0x68,0xFB,0x36};

uint32_t ContentItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->raw);
          this->__isset.raw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->encoding);
          this->__isset.encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->media_type);
          this->__isset.media_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clean_html);
          this->__isset.clean_html = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->clean_visible);
          this->__isset.clean_visible = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->logs.clear();
            uint32_t _size44;
            ::apache::thrift::protocol::TType _etype47;
            xfer += iprot->readListBegin(_etype47, _size44);
            this->logs.resize(_size44);
            uint32_t _i48;
            for (_i48 = 0; _i48 < _size44; ++_i48)
            {
              xfer += iprot->readString(this->logs[_i48]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.logs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->taggings.clear();
            uint32_t _size49;
            ::apache::thrift::protocol::TType _ktype50;
            ::apache::thrift::protocol::TType _vtype51;
            xfer += iprot->readMapBegin(_ktype50, _vtype51, _size49);
            uint32_t _i53;
            for (_i53 = 0; _i53 < _size49; ++_i53)
            {
              TaggerID _key54;
              xfer += iprot->readString(_key54);
              Tagging& _val55 = this->taggings[_key54];
              xfer += _val55.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.taggings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->labelsets.clear();
            uint32_t _size56;
            ::apache::thrift::protocol::TType _etype59;
            xfer += iprot->readListBegin(_etype59, _size56);
            this->labelsets.resize(_size56);
            uint32_t _i60;
            for (_i60 = 0; _i60 < _size56; ++_i60)
            {
              xfer += this->labelsets[_i60].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.labelsets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->sentences.clear();
            uint32_t _size61;
            ::apache::thrift::protocol::TType _ktype62;
            ::apache::thrift::protocol::TType _vtype63;
            xfer += iprot->readMapBegin(_ktype62, _vtype63, _size61);
            uint32_t _i65;
            for (_i65 = 0; _i65 < _size61; ++_i65)
            {
              TaggerID _key66;
              xfer += iprot->readString(_key66);
              std::vector<Sentence> & _val67 = this->sentences[_key66];
              {
                _val67.clear();
                uint32_t _size68;
                ::apache::thrift::protocol::TType _etype71;
                xfer += iprot->readListBegin(_etype71, _size68);
                _val67.resize(_size68);
                uint32_t _i72;
                for (_i72 = 0; _i72 < _size68; ++_i72)
                {
                  xfer += _val67[_i72].read(iprot);
                }
                xfer += iprot->readListEnd();
              }
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.sentences = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->sentence_blobs.clear();
            uint32_t _size73;
            ::apache::thrift::protocol::TType _ktype74;
            ::apache::thrift::protocol::TType _vtype75;
            xfer += iprot->readMapBegin(_ktype74, _vtype75, _size73);
            uint32_t _i77;
            for (_i77 = 0; _i77 < _size73; ++_i77)
            {
              TaggerID _key78;
              xfer += iprot->readString(_key78);
              std::string& _val79 = this->sentence_blobs[_key78];
              xfer += iprot->readBinary(_val79);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.sentence_blobs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ContentItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ContentItem");

  if (this->__isset.raw) {
    xfer += oprot->writeFieldBegin("raw", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeBinary(this->raw);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encoding) {
    xfer += oprot->writeFieldBegin("encoding", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->encoding);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.media_type) {
    xfer += oprot->writeFieldBegin("media_type", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->media_type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clean_html) {
    xfer += oprot->writeFieldBegin("clean_html", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->clean_html);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.clean_visible) {
    xfer += oprot->writeFieldBegin("clean_visible", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->clean_visible);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.logs) {
    xfer += oprot->writeFieldBegin("logs", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->logs.size()));
      std::vector<std::string> ::const_iterator _iter80;
      for (_iter80 = this->logs.begin(); _iter80 != this->logs.end(); ++_iter80)
      {
        xfer += oprot->writeString((*_iter80));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.taggings) {
    xfer += oprot->writeFieldBegin("taggings", ::apache::thrift::protocol::T_MAP, 7);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->taggings.size()));
      std::map<TaggerID, Tagging> ::const_iterator _iter81;
      for (_iter81 = this->taggings.begin(); _iter81 != this->taggings.end(); ++_iter81)
      {
        xfer += oprot->writeString(_iter81->first);
        xfer += _iter81->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.labelsets) {
    xfer += oprot->writeFieldBegin("labelsets", ::apache::thrift::protocol::T_LIST, 8);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->labelsets.size()));
      std::vector<LabelSet> ::const_iterator _iter82;
      for (_iter82 = this->labelsets.begin(); _iter82 != this->labelsets.end(); ++_iter82)
      {
        xfer += (*_iter82).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentences) {
    xfer += oprot->writeFieldBegin("sentences", ::apache::thrift::protocol::T_MAP, 9);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_LIST, static_cast<uint32_t>(this->sentences.size()));
      std::map<TaggerID, std::vector<Sentence> > ::const_iterator _iter83;
      for (_iter83 = this->sentences.begin(); _iter83 != this->sentences.end(); ++_iter83)
      {
        xfer += oprot->writeString(_iter83->first);
        {
          xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(_iter83->second.size()));
          std::vector<Sentence> ::const_iterator _iter84;
          for (_iter84 = _iter83->second.begin(); _iter84 != _iter83->second.end(); ++_iter84)
          {
            xfer += (*_iter84).write(oprot);
          }
          xfer += oprot->writeListEnd();
        }
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sentence_blobs) {
    xfer += oprot->writeFieldBegin("sentence_blobs", ::apache::thrift::protocol::T_MAP, 10);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sentence_blobs.size()));
      std::map<TaggerID, std::string> ::const_iterator _iter85;
      for (_iter85 = this->sentence_blobs.begin(); _iter85 != this->sentence_blobs.end(); ++_iter85)
      {
        xfer += oprot->writeString(_iter85->first);
        xfer += oprot->writeBinary(_iter85->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ContentItem &a, ContentItem &b) {
  using ::std::swap;
  swap(a.raw, b.raw);
  swap(a.encoding, b.encoding);
  swap(a.media_type, b.media_type);
  swap(a.clean_html, b.clean_html);
  swap(a.clean_visible, b.clean_visible);
  swap(a.logs, b.logs);
  swap(a.taggings, b.taggings);
  swap(a.labelsets, b.labelsets);
  swap(a.sentences, b.sentences);
  swap(a.sentence_blobs, b.sentence_blobs);
  swap(a.__isset, b.__isset);
}

const char* Rating::ascii_fingerprint = "3B1E33B2963E1FB49F984B6D0B0C4B05";
const uint8_t Rating::binary_fingerprint[16] = {0x3B,0x1E,0x33,0xB2,0x96,0x3E,0x1F,0xB4,0x9F,0x98,0x4B,0x6D,0x0B,0x0C,0x4B,0x05};

uint32_t Rating::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->annotator.read(iprot);
          this->__isset.annotator = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target_id);
          this->__isset.target_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->relevance);
          this->__isset.relevance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->mentions);
          this->__isset.mentions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Rating::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Rating");

  xfer += oprot->writeFieldBegin("annotator", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->annotator.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->target_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.relevance) {
    xfer += oprot->writeFieldBegin("relevance", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->relevance);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.mentions) {
    xfer += oprot->writeFieldBegin("mentions", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->mentions);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Rating &a, Rating &b) {
  using ::std::swap;
  swap(a.annotator, b.annotator);
  swap(a.target_id, b.target_id);
  swap(a.relevance, b.relevance);
  swap(a.mentions, b.mentions);
  swap(a.__isset, b.__isset);
}

const char* StreamItem::ascii_fingerprint = "A5F62496DCC2C6CCD3EF9D1E25052AD1";
const uint8_t StreamItem::binary_fingerprint[16] = {0xA5,0xF6,0x24,0x96,0xDC,0xC2,0xC6,0xCC,0xD3,0xEF,0x9D,0x1E,0x25,0x05,0x2A,0xD1};

uint32_t StreamItem::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast86;
          xfer += iprot->readI32(ecast86);
          this->version = (Versions::type)ecast86;
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->doc_id);
          this->__isset.doc_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->abs_url);
          this->__isset.abs_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schost);
          this->__isset.schost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->original_url);
          this->__isset.original_url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->body.read(iprot);
          this->__isset.body = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->source_metadata.clear();
            uint32_t _size87;
            ::apache::thrift::protocol::TType _ktype88;
            ::apache::thrift::protocol::TType _vtype89;
            xfer += iprot->readMapBegin(_ktype88, _vtype89, _size87);
            uint32_t _i91;
            for (_i91 = 0; _i91 < _size87; ++_i91)
            {
              std::string _key92;
              xfer += iprot->readString(_key92);
              SourceMetadata& _val93 = this->source_metadata[_key92];
              xfer += iprot->readBinary(_val93);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.source_metadata = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stream_id);
          this->__isset.stream_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->stream_time.read(iprot);
          this->__isset.stream_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->other_content.clear();
            uint32_t _size94;
            ::apache::thrift::protocol::TType _ktype95;
            ::apache::thrift::protocol::TType _vtype96;
            xfer += iprot->readMapBegin(_ktype95, _vtype96, _size94);
            uint32_t _i98;
            for (_i98 = 0; _i98 < _size94; ++_i98)
            {
              std::string _key99;
              xfer += iprot->readString(_key99);
              ContentItem& _val100 = this->other_content[_key99];
              xfer += _val100.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.other_content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->ratings.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _etype104;
            xfer += iprot->readListBegin(_etype104, _size101);
            this->ratings.resize(_size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              xfer += this->ratings[_i105].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.ratings = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t StreamItem::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("StreamItem");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("doc_id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->doc_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.abs_url) {
    xfer += oprot->writeFieldBegin("abs_url", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeBinary(this->abs_url);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.schost) {
    xfer += oprot->writeFieldBegin("schost", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->schost);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.original_url) {
    xfer += oprot->writeFieldBegin("original_url", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeBinary(this->original_url);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source) {
    xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->source);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.body) {
    xfer += oprot->writeFieldBegin("body", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->body.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source_metadata) {
    xfer += oprot->writeFieldBegin("source_metadata", ::apache::thrift::protocol::T_MAP, 8);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->source_metadata.size()));
      std::map<std::string, SourceMetadata> ::const_iterator _iter106;
      for (_iter106 = this->source_metadata.begin(); _iter106 != this->source_metadata.end(); ++_iter106)
      {
        xfer += oprot->writeString(_iter106->first);
        xfer += oprot->writeBinary(_iter106->second);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("stream_id", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->stream_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stream_time", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->stream_time.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.other_content) {
    xfer += oprot->writeFieldBegin("other_content", ::apache::thrift::protocol::T_MAP, 11);
    {
      xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->other_content.size()));
      std::map<std::string, ContentItem> ::const_iterator _iter107;
      for (_iter107 = this->other_content.begin(); _iter107 != this->other_content.end(); ++_iter107)
      {
        xfer += oprot->writeString(_iter107->first);
        xfer += _iter107->second.write(oprot);
      }
      xfer += oprot->writeMapEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ratings) {
    xfer += oprot->writeFieldBegin("ratings", ::apache::thrift::protocol::T_LIST, 12);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ratings.size()));
      std::vector<Rating> ::const_iterator _iter108;
      for (_iter108 = this->ratings.begin(); _iter108 != this->ratings.end(); ++_iter108)
      {
        xfer += (*_iter108).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(StreamItem &a, StreamItem &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.doc_id, b.doc_id);
  swap(a.abs_url, b.abs_url);
  swap(a.schost, b.schost);
  swap(a.original_url, b.original_url);
  swap(a.source, b.source);
  swap(a.body, b.body);
  swap(a.source_metadata, b.source_metadata);
  swap(a.stream_id, b.stream_id);
  swap(a.stream_time, b.stream_time);
  swap(a.other_content, b.other_content);
  swap(a.ratings, b.ratings);
  swap(a.__isset, b.__isset);
}


